---
layout: post
title:
date: 2017-03-21 09:17:21
disqus: y
---

### Learning Puppet

Since I've started my home lab, my tendency has been to run headlong at whatever objective happened to stand next. With OpenLDAP, I learned that this was perhaps not the best strategy; doing so resulted in a lot of fustration born of copious amounts of trial and error. In the case of OpenLDAP, however, I did come away with what I felt to be a more thorough understanding (though I do not intend to insenuate that I deeply understand its administration and inner workings---I certainly do not). Maybe it's self evident, but as complexity compounds, so does requisite research and general study---two things that I am not particularly adept at.

Instead of yielding to weakness, I will instead attempt to distill my learning experience through this blog! Here we goooooo!

---

### Fundamentals of Puppet

*much of what's found below is distilled directly from Puppet's [documentation](https://docs.puppet.com/puppet/4.9/index.html)*

**What is puppet and what does it do?**

Puppet is a configuration management tool written in Ruby. It uses its own declarative language to *declare* resources, classes, state, etc. that should be endemic to nodes on an as defined basis.

**Architecture**

Puppet uses one or more Puppet masters that manage nodes running Puppet agents. On a periodic basis, an agent sends a list of facts about itself to the master and requests a catalog. Facts reference a number of attributes such as a node's IP address, whether a file is present, what services are running, and so on. The requested catalog is a list of attributes that are peculiar to that node; if the agent finds that a resource is not in a desired state, it makes the necessary changes. After applying changes, the agent sends a report to the master.

**About Puppet's DSL**

As alluded to above, Puppet's functionality is predicated on its declarative nature. Puppet's DSL declares resources, and according to the documentation, "every other part of the language exists to add flexibility and convenience to the way resources are declared." Resources are grouped together in classes, where classes define configuration necessary to the functionality of a service or application. Smaller classes may be combined such that they provide a combination of configuration, services, etc. necessary for e.g. a database server. Further, Puppet may also classify nodes. Node definitions dictate what classes should apply to a node. Alternatively, Puppet can utilize data provided from an [External Node Classifier](https://docs.puppet.com/guides/external_nodes.html) or Hiera.

**Resources**

> Resources are the fundamental unit for modeling system configurations. Each resource describes some aspect of a system, like a specific service or package.

Puppet manages all declared resources in its catalogs; a catalog reflects a desired state, ensuring that an applied catalog affects actual state reflecting desired state. 

Resources have associated types that dictate what aspects of configuration that resource manages. Puppet has many built-in resource types such as files, services, and packages. New resource types can be defined in either Puppet or Ruby