---
layout: post
title: Web security and you.
date: 2017-03-26 09:30:45
disqus: y
---

### Why should I care?

About a month and a half ago a coworker pointed out that this site, when tested against [these standards](https://securityheaders.io/?q=blog.tminor.io&followRedirects=on), receives a failing grade. Even more, when tested against [this battery of standards](https://www.ssllabs.com/ssltest/analyze.html?d=blog.tminor.io), my site barely passed, receiving a C.

In reality, I could get away with trivializing these issues. This site is just a pet project that serves no mission critical importance; it's not used to serve sensitive information; it doesn't host any web applications (at least ones that I've written); I could have shrugged it off and ignored it. But no! Defeatism begets mediocrity and no one wants to be average!

---

### Security headers and you.

The tests linked above examine different aspects of web security. I'll start with [https://securityheaders.io](https://securityheaders.io), through which this site received a big fat "F." What sort of implications underly a lack of HTTP security headers?

**HTTP basics**

Let's assume some measure of ignorance and establish a basic foundational knowledge of HTTP. From [RFC 7230](https://tools.ietf.org/html/rfc7230):

> The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.

More pragmatically, HTTP is a request/response protocol that functions to deliver messages over a session-layer connection between a client and server. A client may be any of a variety of applications that submits an HTTP request to a system that runs an application that responds to said HTTP requests. A typical HTTP message takes the form of a retrieval request (GET). A request message begins with a request line, specifying a [method token](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html), a [Uniform Resource Identifier](https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2) (URI), and the protocol version, followed by header fields (which we care about for this post) and the CRLF (Carriage Return Line Feed), indicating the expectation that the message body containing a payload is to follow (if necessary).

**What purpose do headers serve?**

We'll start with an example. Running `curl -I` against this site returns:

```
HTTP/1.1 200 OK
Date: Sun, 26 Mar 2017 15:56:39 GMT
Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.1e-fips
Last-Modified: Tue, 21 Mar 2017 15:36:46 GMT
ETag: "12a0-54b3f6958bf80"
Accept-Ranges: bytes
Content-Length: 4768
Content-Type: text/html; charset=UTF-8
```

Again, from RFC 7230:

> Each header field consists of a case-insensitive field name followed by a colon (":"), optional leading whitespace, the field value, and optional trailing whitespace.

Many of the fields above are defined in RFC 7230, but 7230 also specifies that header fields are fully extensible. As such, HTTP has seen the addition of headers that specify certain HTTP delivery methods that ensure certain levels of security.